# Network File System (NFS)


**NFS** (`Network File System`) คือระบบไฟล์เครือข่ายที่พัฒนาโดย Sun Microsystems มีจุดประสงค์คล้ายกับ SMB คือ ทำให้เราสามารถเข้าถึงไฟล์ในเครือข่ายได้เหมือนกับไฟล์ที่อยู่ในเครื่องของเราเอง แต่ใช้โปรโตคอลที่ต่างกันโดยสิ้นเชิง

- **ใช้กับระบบไหน**: Linux และ Unix (ไม่ใช่ Windows โดยตรง)
- **ข้อจำกัด**: เครื่อง NFS ไม่สามารถสื่อสารกับเซิร์ฟเวอร์ SMB ได้โดยตรง

## ความแตกต่างของแต่ละเวอร์ชัน

### การยืนยันตัวตน (Authentication)
- **NFSv3**: ยืนยันตัวตนที่ระดับ**เครื่องคอมพิวเตอร์**
```
เครื่อง A (10.129.14.50):
  - User "admin" login → เข้า NFS ได้ (rw) ✅
  - User "guest" login → เข้า NFS ได้ (rw) ✅
  - User "hacker" login → เข้า NFS ได้ (rw) ✅
  
  ทุกคนบนเครื่องเดียวกันได้สิทธิ์เท่ากัน!
```

### ปัญหา ❌
- **ไม่รู้ว่าใครกำลังใช้งาน** เพียงแค่รู้ว่ามาจากเครื่องไหน
- ถ้ามีคนแอบใช้เครื่องที่ได้รับอนุญาต = เข้าได้ทันที
- ไม่สามารถควบคุมสิทธิ์แยกตามผู้ใช้ได้
---
- **NFSv4**: ยืนยันตัวตนที่ระดับ**ผู้ใช้** (เหมือน Windows SMB)


```
เครื่อง A (10.129.14.50):
  - User "admin" → ต้อง login ด้วย Kerberos ก่อน
    → ถ้าผ่าน: เข้า NFS ได้ ✅
    
  - User "guest" → ต้อง login ด้วย Kerberos ก่อน
    → ถ้าไม่มีสิทธิ์: เข้าไม่ได้ ❌
    
  - User "hacker" → แม้จะอยู่บนเครื่องเดียวกัน
    → ถ้าไม่มี credential: เข้าไม่ได้ ❌
```

### ข้อดี ✅
- **รู้แน่ชัดว่าใครกำลังใช้งาน**
- สามารถกำหนดสิทธิ์แยกตามแต่ละคนได้
- ปลอดภัยกว่ามาก



---

### เปรียบเทียบเวอร์ชัน

| เวอร์ชัน | คุณสมบัติเด่น |
|---------|--------------|
| **NFSv2** | - เวอร์ชันเก่าแต่รองรับหลายระบบ<br>- ใช้ผ่าน UDP เท่านั้น |
| **NFSv3** | - มีฟีเจอร์เพิ่มขึ้น เช่น ขนาดไฟล์ที่ยืดหยุ่นกว่า<br>- รายงานข้อผิดพลาดได้ดีขึ้น<br>- แต่ใช้งานร่วมกับ NFSv2 ไม่ได้อย่างสมบูรณ์ |
| **NFSv4** | - รองรับ Kerberos (ระบบความปลอดภัย)<br>- ทำงานผ่าน firewall และอินเทอร์เน็ตได้<br>- ไม่ต้องใช้ portmapper อีกต่อไป<br>- รองรับ ACLs (การควบคุมสิทธิ์ขั้นสูง)<br>- ปลอดภัยและทำงานได้เร็วขึ้น<br>- เป็นเวอร์ชันแรกที่มี stateful protocol |

### NFSv4.1 (RFC 8881)
- รองรับการทำงานแบบคลัสเตอร์
- รองรับ **pNFS** (parallel NFS) สามารถเข้าถึงไฟล์จากหลายเซิร์ฟเวอร์พร้อมกันได้
- มี **session trunking** หรือ NFS multipathing (สามารถใช้หลายเส้นทางเครือข่ายพร้อมกัน)

### ข้อดีสำคัญของ NFSv4
ใช้เพียง**พอร์ตเดียว** (`2049`) ไม่ว่าจะเป็น UDP หรือ TCP ทำให้ผ่าน firewall ได้ง่ายขึ้น

## เทคโนโลยีพื้นฐาน

NFS ทำงานบนพื้นฐานของ **ONC-RPC/SUN-RPC** protocol ซึ่ง:
- ใช้พอร์ต `111` (TCP และ UDP)
- ใช้ **XDR** (External Data Representation) เพื่อแลกเปลี่ยนข้อมูลระหว่างระบบที่แตกต่างกัน


### NFS ไม่มีระบบยืนยันตัวตนในตัว!
- NFS protocol **ไม่มี**กระบวนการ**ยืนยันตัวตน** (authentication) หรือ**การอนุญาต** (authorization) ในตัวเอง
- การยืนยันตัวตนถูกโยนไปให้ RPC protocol จัดการแทน
- เซิร์ฟเวอร์จะแปลงข้อมูลผู้ใช้ให้เป็นรูปแบบที่ระบบไฟล์เข้าใจได้

### วิธีการยืนยันตัวตนทั่วไป
ใช้ **UNIX UID/GID** และ **group memberships**

### ปัญหาด้านความปลอดภัย
- **เครื่อง client และ server อาจมีการจับคู่ UID/GID กับผู้ใช้ที่ไม่เหมือนกัน**
- Server **ไม่สามารถตรวจสอบเพิ่มเติมได้**
- ไม่มีการยืนยันความถูกต้องเพิ่มเติมจากฝั่ง server

# อธิบาย ONC-RPC/SUN-RPC และ XDR

## NFS ทำงานอย่างไร?

NFS ไม่ได้ทำงานเพียงลำพัง แต่ต้องอาศัย**ระบบพื้นฐาน**หลายตัวช่วย

```
┌─────────────────────────────────────┐
│         NFS Protocol                │  ← สิ่งที่เราใช้
├─────────────────────────────────────┤
│      RPC (Remote Procedure Call)    │  ← ระบบเรียกใช้งานระยะไกล
├─────────────────────────────────────┤
│      XDR (Data Format)              │  ← รูปแบบข้อมูล
├─────────────────────────────────────┤
│      TCP/UDP                        │  ← เครือข่าย
└─────────────────────────────────────┘
```

---

## 1. **ONC-RPC / SUN-RPC** คือระบบเรียกใช้ฟังก์ชันระยะไกล

### RPC = Remote Procedure Call

**แนวคิด:** เรียกใช้ฟังก์ชันบนเครื่องอื่นเหมือนเรียกใช้ในเครื่องตัวเอง

```
┌──────────────┐                    ┌──────────────┐
│   CLIENT     │                    │   SERVER     │
├──────────────┤                    ├──────────────┤
│              │  1. เรียกฟังก์ชัน │              │
│ read_file()  │ ─────────────────> │              │
│              │                    │ read_file()  │
│              │  2. ส่งผลลัพธ์กลับ│ {รันจริงๆ}   │
│              │ <───────────────── │              │
│ ได้ข้อมูล!  │                    │              │
└──────────────┘                    └──────────────┘
```

### ทำไมเรียกว่า ONC-RPC หรือ SUN-RPC?

- **ONC-RPC** = Open Network Computing RPC (ชื่อมาตรฐาน)
- **SUN-RPC** = ชื่อเดิมที่ Sun Microsystems พัฒนา
- **เป็นตัวเดียวกัน** แค่เรียกชื่อต่างกัน

---

## 2. **พอร์ต 111** - Portmapper/rpcbind

### Portmapper คืออะไร?

เปรียบเทียบกับ**แผนกต้อนรับ**ในบริษัท

```
Client: "ขอใช้บริการ NFS หน่อย"
              ↓
      Portmapper (พอร์ต 111)
      "NFS อยู่ที่พอร์ต 2049 นะครับ"
              ↓
Client เชื่อมต่อไปที่พอร์ต 2049
```

### การทำงานจริง:

```bash
# ดูว่า RPC services ทำงานที่พอร์ตไหนบ้าง
$ rpcinfo -p
   program vers proto   port  service
    100000    4   tcp    111  portmapper
    100003    3   tcp   2049  nfs
    100005    3   tcp  20048  mountd
    100021    4   tcp  37521  nlockmgr
```

**อธิบาย:**
- **portmapper** (พอร์ต 111) = ตัวจัดการหลัก
- **nfs** (พอร์ต 2049) = บริการ NFS จริงๆ
- **mountd** (พอร์ต 20048) = จัดการการ mount
- **nlockmgr** (พอร์ต 37521) = จัดการ file locking

### ขั้นตอนการเชื่อมต่อ:

```
1. Client → Server พอร์ต 111
   "ขอถามหน่อย NFS อยู่พอร์ตไหน?"

2. Portmapper ตอบกลับ
   "NFS อยู่พอร์ต 2049"

3. Client → Server พอร์ต 2049
   "ขอเชื่อมต่อ NFS เลย"

4. ใช้งาน NFS ได้
```

---

## 3. **XDR** (External Data Representation)

### ปัญหาที่ XDR แก้ไข

เครื่องคอมพิวเตอร์แต่ละเครื่อง**เก็บข้อมูลต่างกัน**!

### ตัวอย่าง: เก็บเลข 12345

**Little Endian** (Intel, AMD):
```
หน่วยความจำ:  [39] [30] [00] [00]
               ↑ เก็บ byte ต่ำก่อน
```

**Big Endian** (บาง CPU):
```
หน่วยความจำ:  [00] [00] [30] [39]
               ↑ เก็บ byte สูงก่อน
```

**ถ้าไม่แปลง = ข้อมูลผิด!**

---

### XDR ทำหน้าที่แปลงข้อมูล

```
┌──────────────┐                    ┌──────────────┐
│   CLIENT     │                    │   SERVER     │
│ (Intel CPU)  │                    │  (ARM CPU)   │
├──────────────┤                    ├──────────────┤
│              │                    │              │
│ 12345        │  1. แปลงเป็น XDR  │              │
│ [39][30]...  │ ─────────────────> │              │
│              │  XDR: มาตรฐานกลาง │              │
│              │                    │ 2. แปลงเป็น  │
│              │                    │    รูปแบบของ │
│              │                    │    Server     │
│              │  3. ส่งผลลัพธ์กลับ│ 12345        │
│              │ <───────────────── │              │
└──────────────┘                    └──────────────┘
```

### XDR แปลงอะไรบ้าง?

| ประเภทข้อมูล | การแปลง |
|-------------|---------|
| **จำนวนเต็ม** | เปลี่ยนจาก Little/Big Endian เป็นมาตรฐาน |
| **ทศนิยม** | แปลง floating-point ให้เหมือนกัน |
| **ข้อความ** | จัดการ encoding และขนาด |
| **โครงสร้างข้อมูล** | แปลง struct/array ให้เข้าใจกันได้ |

---

## ตัวอย่างการทำงานทั้งหมด

### สถานการณ์: Client ต้องการอ่านไฟล์จาก NFS Server

```
┌─────────────────────────────────────────────────────────┐
│ ขั้นตอนที่ 1: หา NFS Service                           │
└─────────────────────────────────────────────────────────┘

Client ──[ถาม: NFS อยู่ไหน?]──> Server พอร์ต 111 (Portmapper)
Client <──[ตอบ: พอร์ต 2049]──── Server


┌─────────────────────────────────────────────────────────┐
│ ขั้นตอนที่ 2: เรียกใช้ RPC - ขอ mount                   │
└─────────────────────────────────────────────────────────┘

Client ──[RPC: mount /mnt/nfs]──> Server พอร์ต 2049
       │                          │
       │ ข้อมูลถูกแปลงด้วย XDR   │
       │                          ↓
       │                      ตรวจสอบสิทธิ์
       │                      mount ได้หรือไม่?
       │                          │
Client <──[RPC Reply: OK]──────── Server


┌─────────────────────────────────────────────────────────┐
│ ขั้นตอนที่ 3: อ่านไฟล์                                  │
└─────────────────────────────────────────────────────────┘

Client ──[RPC: read file.txt]──> Server
       │ UID=1000                │
       │ GID=1000                │
       │ XDR Format              ↓
       │                     เช็คสิทธิ์ UID/GID
       │                     อ่านไฟล์
       │                         │
Client <──[RPC Reply: data]────  Server
       ↓
   ได้ข้อมูลแล้ว!
   แปลง XDR กลับเป็นข้อมูลปกติ
```

---

## การตรวจสอบ RPC Services

### คำสั่งที่ใช้บ่อย:

```bash
# 1. ดู RPC services ทั้งหมด
$ rpcinfo -p 10.129.14.5
   program vers proto   port  service
    100000    4   tcp    111  portmapper
    100003    3   tcp   2049  nfs
    100005    3   tcp  20048  mountd

# 2. ดูว่า NFS แชร์โฟลเดอร์อะไรบ้าง
$ showmount -e 10.129.14.5
Export list for 10.129.14.5:
/mnt/nfs 10.129.14.0/24

# 3. สแกนพอร์ต RPC ด้วย nmap
$ nmap -sV -p 111 10.129.14.5
PORT    STATE SERVICE VERSION
111/tcp open  rpcbind 2-4 (RPC #100000)
```

---

## ทำไมต้องรู้เรื่องนี้?

### เพื่อความปลอดภัย! 🔒

**จุดอ่อน:**

1. **พอร์ต 111 เปิดอยู่ = เปิดเผยข้อมูล**
   ```bash
   # ใครก็ตามสามารถถามได้ว่ามี service อะไรทำงานบ้าง
   $ rpcinfo -p target.com
   # ได้ข้อมูลทั้งหมด!
   ```

2. **RPC ไม่มีการเข้ารหัส**
   ```
   ข้อมูลถูกส่งแบบ plain text!
   ใครก็ดักจับได้ (sniff network traffic)
   ```

3. **ไม่มีการยืนยันตัวตนที่แข็งแกร่ง**
   ```
   ใช้แค่ UID/GID ซึ่งปลอมได้ง่าย
   ```

### วิธีป้องกัน:

✅ **ปิดพอร์ต 111 จากภายนอก** (ใช้ firewall)
✅ **ใช้ NFSv4** (ไม่ต้องพึ่ง portmapper)
✅ **ใช้ VPN หรือ SSH Tunnel** (เข้ารหัสการสื่อสาร)
✅ **ใช้เฉพาะในเครือข่ายภายใน** (trusted network)

---

## สรุป

### ONC-RPC/SUN-RPC:
- เป็น**ระบบเรียกใช้ฟังก์ชันระยะไกล**
- NFS ใช้ RPC เป็นพื้นฐานในการสื่อสาร
- ใช้**พอร์ต 111** สำหรับ Portmapper (บอกว่า service อยู่พอร์ตไหน)

### XDR:
- เป็น**รูปแบบข้อมูลมาตรฐาน**
- แปลงข้อมูลระหว่างเครื่องที่มี architecture ต่างกัน
- ทำให้เครื่อง Intel สื่อสารกับ ARM ได้

### เปรียบเทียบง่ายๆ:
```
RPC    = ระบบโทรศัพท์ (โทรไปเรียกใช้ฟังก์ชัน)
XDR    = ล่าม (แปลภาษาให้เข้าใจกัน)
พอร์ต 111 = แผนกต้อนรับ (บอกว่าแต่ละแผนกอยู่ไหน)
```

### จุดอ่อนด้านความปลอดภัย:
- ข้อมูลไม่เข้ารหัส
- พอร์ต 111 เปิดเผยข้อมูล service
- ง่ายต่อการโจมตี

